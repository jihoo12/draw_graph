e^{ix} graph
fn generate_3d_graph() -> (Vec<Vertex>, Vec<u16>) {
    let mut vertices = Vec::new();
    let mut indices = Vec::new();

    let resolution = 1000; // 나선을 부드럽게 그리기 위해 점의 개수를 늘립니다.
    let x_min = -10.0;
    let x_max = 10.0;
    let step = (x_max - x_min) / (resolution as f32 - 1.0);

    // 1. 정점(Vertex) 생성: x축을 따라 이동하며 나선형 점들을 찍습니다.
    for i in 0..resolution {
        let x = x_min + (i as f32) * step;

        // e^{ix} = cos(x) + i*sin(x)
        let y = x.cos(); // 실수부 (y축)
        let z = x.sin(); // 허수부 (z축)

        // y값(실수부)에 따라 명암을 줘서 흑백 와이어프레임의 입체감을 살립니다.
        let brightness = (y + 1.0) / 2.0;
        let color = [brightness, brightness, brightness];

        vertices.push(Vertex {
            position: [x, y, z],
            color,
        });
    }

    // 2. 인덱스(Index) 생성: 점들을 순서대로 하나의 긴 선으로 연결합니다.
    for i in 0..(resolution - 1) {
        indices.push(i as u16);
        indices.push((i + 1) as u16);
    }

    (vertices, indices)
}

some cool graph
fn generate_3d_graph() -> (Vec<Vertex>, Vec<u16>) {
    let mut vertices = Vec::new();
    let mut indices = Vec::new();

    let resolution = 50;
    let size = 10.0;
    let step = size / (resolution as f32 - 1.0);
    let offset = size / 2.0;

    // 1. 정점(Vertex) 생성 (기존과 동일하게 회색조 유지)
    for z in 0..resolution {
        for x in 0..resolution {
            let px = (x as f32) * step - offset;
            let pz = (z as f32) * step - offset;

            let distance = (px * px + pz * pz).sqrt();
            let py = distance.sin();

            // 흑백(회색조) 색상
            let brightness = (py + 1.0) / 2.0;
            let color = [brightness, brightness, brightness];

            vertices.push(Vertex {
                position: [px, py, pz],
                color,
            });
        }
    }

    // 2. 인덱스(Index) 생성: 와이어프레임(선) 연결 방식
    for z in 0..resolution {
        for x in 0..resolution {
            let current = z * resolution + x;

            // 가로선 연결 (오른쪽 점과 연결, 끝점이 아닐 때만)
            if x < resolution - 1 {
                indices.push(current as u16);
                indices.push((current + 1) as u16);
            }

            // 세로선 연결 (아래쪽 점과 연결, 끝점이 아닐 때만)
            if z < resolution - 1 {
                indices.push(current as u16);
                indices.push((current + resolution) as u16);
            }
        }
    }

    (vertices, indices)
}
